---
`title: 运算符语法设计
author: GodGnidoc
date: 2019/05/07
lang: Chinese
encoding: utf8
---

# 概述

本文档描述`Alioth`编程语言`0.9`版本下的运算符重载语法，其中包括特化运算符9种，泛化运算符若干，讨论方面包括运算符的本质，运算符重载的定义语法和实现语法，以及各种运算符重载的行为特征。

[TOC]

# 1. 运算符重载

运算符重载可以产生或替换一个**运算符$_{operator}$**，赋予一种数据类型新的行为能力。

在源代码中，使用对应运算符将对象链接进入表达式则构成对运算符的调用。

运算符应当用于处理轻量级任务，所以**默认情况下，运算符被标记为<u>原子过程</u>**。

由**运算符**`op`关联的对象`a`和`b`，被称为**运算子$_{operand}$**。

根据运算规则，最先被求值参与运算的**运算子**被称为**主运算子$_{master\ operand}$**。

剩余的**运算子**若存在，则称为**从运算子$_{slave\ operand}$**。

在**简单数据类型$_{SimpleType}$**之间，根据**运算符结合性方向**选取主从运算子。

在**复合数据类型$_{CompositeType}$**与其他数据类型之间，根据从左到右的顺序寻找第一个拥有此运算符重载的对象作为主运算子。

# 2. 特化运算符

**特化运算符是类定义伴生复合数据类型默认必备的运算符。**

**定制型特化运算符未被重载之前不存在，所以类定义伴生复合数据类型默认不拥有这些运算符。**

通过一个移除签名，可以删除一个默认存在的特化运算符。

特化运算符共有九种，包括**结构化构造运算符、序列化构造运算符、析构运算符、拷贝构造运算符、移动构造运算符、类型转换运算符、成员运算符、定位运算符**和**移动运算符**。

## 2.1. 结构化构造运算符

结构化构造运算符$_{Structural\ Constructor}$提供结构化的对象构造语法支持。默认情况下，复合数据类型拥有一个不接受任何参数的结构化构造运算符，这个默认的结构化构造运算符对复合数据类型的所有成员调用默认构造运算符。

重载任何形式的结构化构造运算符都会删除默认提供的结构化构造运算符。最终，唯一一个可以不接受任何参数的结构化构造运算符被视为**默认构造运算符**。

### 2.1.1. 定义

结构化构造运算符的标签是`{...}`，也可以使用`sctor`作为结构化构造运算符的标签。

~~~
operator {...} ( arg1 Type, arg2 Type = Expr, arg3 Type, ... args )
operator sctor( arg1 Type = Expr, arg2 Type, arg3 Type = Expr )
~~~

### 2.1.2. 实现

结构化构造运算符的实现体是一个**构造器**，构造器描述了复合数据类型对象的每一个成员的构造规则，未被提及的成员，编译器试图调用其默认构造运算符。

构造器由三部分构成：**基类构造表达式，成员构造列表，后置构造过程**。

~~~
operator Scope::Class sctor( arg1 Type, arg2 Type, arg3 Type ) {
    {BasicTypeA| param:Expr}
    {BasicTypeB| param:Expr, param:Expr}
    
    attr : Expr, attr : Expr, attr : Expr |

    // Do something ...
}
~~~

基类构造表达式被置于成员构造列表之前，没有顺序要求，若没有基类，此部分可省。

成员构造列指定一些成员的构造表达式

后置构造过程与成员构造列表之间用`|`分割，分隔符优先级次于其运算符语义。后置构造过程用于处理一些成员构造之外的事情，在所有成员都正确构造之后被执行，若不需要，此部分连同分隔符可省。

### 2.1.3. 调用

结构化构造运算符的调用通过书写**结构化构造表达式**实现。

结构化构造表达式由可选的类型描述符和传参列表构成，中间使用分隔符`|`分割。

~~~
obj conn = {HttpConnection|
    Url: "http://dn-ezr.cn",
    Method: Http::GET };

obj comm Comm = {
    name: "COM4",
    bandrate: 9600,
    stopbit: 1 };
~~~

结构化构造表达式的参数必须带参数名传递，因此消除了顺序的必要性，可以安排任意参数的默认参数，减小重载量。

## 2.2. 序列化构造运算符

序列化构造运算符$_{List\ Constructor}$提供用于构造序列对象的直观语法支持。序列化构造运算符是定制类特化运算符，默认情况下复合数据类型不拥有序列化构造运算符。

### 2.2.1. 定义

序列化构造运算符的标签是`[...]`，也可以使用`lctor`作为序列化构造运算符的标签。

~~~
operator [...] ( arg1 Type, ... args )
operator lctor ( arg1 Type, arg2 Type, ... args Type )
~~~

虽然序列化构造运算符的参数列表是随意定制的，但`Alioth`更鼓励开发人员提供可变参数包` ... args `。

### 2.2.2. 实现

序列化构造运算符同样是构造运算符，其运算符体同结构化构造运算符一样，也是一个构造器。

~~~
operator Scope::Class [...] ( arg1 Type, arg2 Type, ... args Type ) {
    {BasicType| param:Expr}
    attr: Expr, attr Expr |
    // Do something ...
}
~~~

### 2.2.3. 调用

在构造语境或表达式中，使用`[]`引导序列化构造运算符的调用。

~~~
obj nameList = [class List<string>| "GodGnidoc", "lzl" ];

obj conn = {HttpConnection|
	Url: "http://dn-ezr.cn",
	Method: Http:GET,
	Params: [<"Name","Ezr">,<"Action","Login">]
}
~~~

序列化构造表达式的类型标签不要求`class`关键字的引导，但是示例中的`List<string>`是带模板参数列表的类型用例，需要`class`引导一个类型用例的语境。

## 2.3. 析构运算符

析构运算符与**析构函数**没有实质性的差别，析构运算符的设计是为了和构造运算符统一风格。

### 2.3.1. 定义

析构运算符的运算符标签是`{~}`，也可以使用`dtor`作为析构运算符的标签。

~~~
operator {~}()
~~~

~~~
operator dtor()
~~~

### 2.3.2. 实现

析构运算符的运算符体是一个指令块

~~~
operator Scope::Class dtor() {
	// Do something ...
}
~~~

### 2.3.3. 调用

无论何时，您都不能主动调用对象的析构运算符，它应当在对象即将被析构之前被触发。

## 2.4. 拷贝构造运算符

默认的拷贝构造运算符对所有的属性调用拷贝构造运算符。

对于复合数据类型对象，默认拷贝构造运算符调用其拷贝构造运算符。

对于简单数据类型对象和复合数据类型的其他元素，默认拷贝构造运算符直接拷贝其值。

### 2.4.1. 定义

拷贝构造运算符的标签是`{=}`，您也可以使用`cctor`作为拷贝构造运算符的标签。

~~~
operator {=}( an )
~~~

~~~
operator cctor( an )
~~~

其中`an`的类型一定是`ref const an Type`所以数据类型和元素类型都是可省的。

### 2.4.2. 实现

拷贝构造运算符的实现体是一个构造器。

### 2.4.3. 调用

拷贝构造运算符不需要显式调用，在构造，传参，运算过程中，直接传入能用于调用拷贝构造运算符的元素即刻。

~~~
obj Second Class = First;
~~~

## 2.5. 移动构造运算符

移动构造运算符是使用重载元素构造一个对象时被触发的构造运算符。

移动构造运算符默认情况下和默认拷贝构造运算符的行为完全一样。

### 2.5.1. 定义

移动构造运算符的标签是`{<}`，您也可以使用`mctor`作为移动构造运算符的标签。

~~~
operator {<} ( an )
~~~

~~~
operator mctor( an )
~~~

### 2.5.2. 实现

移动构造运算符的实现是一个构造器。

### 2.5.3. 调用

同拷贝构造运算符一样，移动构造运算符在特定情况下被触发。

~~~
obj Data Class = come as rel;
~~~

## 2.6. 类型转换运算符

`Alioth`中规定，类型转换运算符必须返回`ref`类型的元素。

### 2.6.1. 定义

类型转换运算符的标签是`as`关键字，带一个类型用例作为副标题。

~~~
operator as Type ()
~~~

不需要为类型转换运算符指定额外的返回值元素原型，因为它一定是`ref Type`。

### 2.6.2. 实现

类型转换运算符的运算符体是一个指令块。

~~~
operator Scope::Class as Type() {
	// Do something ...
}
~~~

### 2.6.3. 调用

类型转换运算符不仅可以显式调用，在发生自动类型转换时也可能被调用。

~~~
ref r = Data as Integer;
~~~

类型转换表达式由`as`关键字引导，可以指定一个元素类型或一个数据类型来进行转换。

## 2.7. 成员运算符

成员运算符用于拦截对一个成员符号的访问。

成员运算符的符号与成员符号互斥。

### 2.7.1. 定义

成员运算符的符号是`.`您也可以使用`member`作为成员运算符的标签。

~~~
operator member name() obj string
~~~

~~~
operator . encoding( en Encoding ) ref Encoding
~~~

对同一个符号可以重载多个成员运算符，最多只能有一个参数。

没有参数的重载在被提取时使用，有参数的重载在被赋值时使用。

### 2.7.2. 实现

成员运算符的运算符体是一个指令块。

~~~
operator Scope::Class member name() obj string {
	// Do something ...
}
~~~

### 2.7.3 调用

当成员运算表达式出现在**赋值运算符**左侧，编译器要求一个带参数的成员运算符被重载。

其他情况下，编译器调用一个不带参数的成员运算符。

## 2.8. 定位运算符

定位运算符类似于成员运算符，是纯粹的定制运算符。

定位运算符能接受一个十进制字面常量作为副标题。

定位运算符不能接受参数。

### 2.8.1. 定义

定位运算符的标签是`#`您也可以使用`where`作为定位运算符的标签。

~~~
operator # 0 () obj int32
operator where 4 () ref Class
~~~

对同一个副标题，定位运算符可以有`const`和非`const`两个重载版本。

### 2.8.2. 实现

定位运算符的运算符体是一个指令块

~~~
operator Scope::Class locate 3() obj string {
	// Do something ...
}
~~~

### 2.8.3. 调用

使用`#`调用定位运算符。

~~~
obj name = record # 2;
~~~

## 2.9. 移动运算符

移动运算符用于当对象需要被移动闭包时，给用于机会处理这个事件。

移动运算符默认不做任何操作，如果一个被闭包的对象没有重载移动运算符，则编译器给出警告。

### 2.9.1. 定义

移动运算符只有一个约定标签`move`

~~~
operator move( p ^ this class ) void
~~~

移动运算符必须返回`void`。

移动运算符必须接受`^ this class`数据类型，参数的意义是即将用于存储当前对象的新地址。

### 2.9.2. 实现

移动运算符的运算符体是一个指令块。

~~~
operator Scope::Class move( ptr p ^ this class ) void {
	// Do something ...
}
~~~

### 2.9.3. 调用

当对象被闭包离开这个作用域时，对象会被纳入**GC空间**被**GC系统**管理起来，在这之前，编译器会自动调用移动运算符。

除此之外，没有显式手段调用移动运算符。

# 3. 泛化运算符

泛化运算符是指复合数据类型原本不拥有的所有运算符。

其中，指针运算符是不能重载的。

赋值运算符和单目运算符不能反重载。

## 3.1. 单目运算符

单目运算符包括前缀运算符和后缀运算符。

默认情况下只重载前缀运算符，若前缀运算符和后缀运算符的标签相同，您可以使用约定的`suffix`修饰符来修饰运算符。

~~~
operator increase ( v int32 ) ref this class
operator suffix increase ( v int32 ) obj this class
~~~

当然了，您也可以添加`prefix`修饰一个单目运算符为前缀运算符，让代码看起来更整齐。

~~~
operator prefix increase( v int32 ) ref this class
operator suffix increase( v int32 ) ref this class
~~~

可重载的单目运算符如下表所列：

| 运算符 | 标签     | 描述     |
| ------ | -------- | -------- |
|        | negative | 负号     |
| `~`    | bitrev   | 按位取反 |
| `++`   | increase | 自增     |
| `--`   | decrease | 自减     |
| `not`  |          | 逻辑非   |

## 3.2. 赋值运算符

赋值运算符的标签是`assign`，您可以使用赋值运算符本身`=`或它的标签来定义一个重载。

赋值运算符由于其语义性质，不能选取运算符右侧的运算子作为主运算子，<u>赋值运算符所以不允许反重载</u>。

~~~
operator assign ( obj an this class ) ref this class
~~~

<u>赋值运算符必须返回`ref this class`</u>。

对于复合赋值运算符，您可以使用运算符本身或将复合运算作为副标题加入运算符重载的定义中。

~~~
operator += ( obj an this class ) ref this class
operator assign add ( obj an this class ) ref this class
~~~

下表列出了复合赋值运算符和它们的组合标签：

| 运算符 | 组合标签        |
| ------ | --------------- |
| `+=`   | `assign add`    |
| `-=`   | `assign sub`    |
| `*=`   | `assign mul`    |
| `/=`   | `assign div`    |
| `%=`   | `assign mol`    |
| `<<=`  | `assign shl`    |
| `>>=`  | `assign shr`    |
| `&=`   | `assign bitand` |
| `|=`   | `assign bitor`  |
| `^=`   | `assign bitxor` |

## 3.3. 双目运算符

双目运算符从左向右选择主运算子，若左运算子没有重载此运算符，则检查右运算子。如果两个运算子都没有对应运算符能处理这次运算，则运算语义错误。

下表列出了所有双目运算符和它们的标签，有些运算符的标签和**保留字**完全一样，请不要担心，约定的级别高于保留字，在约定语境成立的情况下，保留字也会被视为约定标签。

| 运算符 | 标签     |
| ------ | -------- |
| `+`    | `add`    |
| `-`    | `sub`    |
| `*`    | `mul`    |
| `/`    | `div`    |
| `%`    | `mol`    |
| `&`    | `bitand` |
| `|`    | `bitor`  |
| `^`    | `bitxor` |
| `<<`   | `shl`    |
| `>>`   | `shr`    |
| `<`    | `lt`     |
| `>`    | `gt`     |
| `<=`   | `le`     |
| `>=`   | `ge`     |
| `==`   | `eq`     |
| `!=`   | `ne`     |
| `and`  |          |
| `or`   |          |
| `xor`  |          |
| `[]`   | `index`  |