---
title: 新语法特性
date: 2019/05/09
author: GodGnidoc
encoding: utf8
lang: Chinese
---

# 概述

本文档描述`Alioth`语言在`0.9`版本中引入的新的语法特性。

[TOC]

# 约定

在Alioth各个语法结构中，都存在着对某种数据结构的接口的约定。

约定分为**标签约定**和**特性约定**。

约定的主要作用是减小语法特性对语法结构的影响范围，最大程度上开放用户的编码自由度。

约定的优先级高于**保留字**，当约定条件成立时，即使一个约定指向了一个保留字，它也会被视为一个约定标签。

## 标签约定

标签约定系列约定某种名称具有确定的语义。

### 字符串

`Alioth`约定类型用例`string`所指向的类总用于描述一个**字符串**。

### 字符

`Alioth`约定类型用例`char`所指向的类总用于描述一个**字符**。

### 元组

`Alioth`约定类型用例`tuple`所指向的模板类总用于描述**元组**类型。

### 执行流展开宿主

`Alioth`约定类型用例`DefUnwindHost`所指向的类是**默认执行流展开宿主**。

### 修饰符

在特定语境下，可以使用约定的修饰符修饰语法结构。

#### 抽象类

在定义语境中，`class`关键字和下一个标识符之间，允许出现一个`abstract`标签，修饰这个类为**抽象类**。

```
class abstract TaskDesc {
	// Define something ...
}
```

#### 运算符反重载

在定义运算符的语境中，可以使用`rev`标签修饰运算符，表示一个反重载。

~~~
operator rev add( an int32 ) obj int32
~~~

#### 运算符正反同构

在定义运算符的语境中，可以使用`ism`标签修饰运算符，表示这是一个运算符的正反同构重载。

~~~
operator ism add（ an int32 ) obj int32
~~~

#### 前缀单目运算符

在定义运算符的语境中，可以使用`prefix`标签修饰运算符，表示这是一个前缀单目运算符。

~~~
operator prefix increase( an int32 ) obj int32
~~~

#### 后缀单目运算符

在定义运算符语境中，可以使用`suffix`标签修饰运算符，表示这是一个后缀单目运算符

~~~
operator suffix increase( an int32 ) obj int32
~~~

#### 原子方法

在定义方法的语境中，在`method`关键字和下一个标识符之间，允许出现一个`atomic`标签，修饰这个方法是原子方法。

~~~
method atomic join() void
~~~

### 原始符号

在定义方法语境中，可以使用`raw`标签标记方法使用原始标签。

~~~
method raw met() void
method raw "symbol" met() void
~~~

### 运算符标签

在运算符定义语境中，可以使用约定的运算符标签来表示运算符，如此可以使得一些无法书写的运算符得以重载，另外一方面，此特性可一个用于提高代码的美观性。

| 运算符标签 | 运算符书写 | 描述             |
| ---------- | ---------- | ---------------- |
| `sctor`    | `{...}`    | 结构化构造运算符 |
| `lctor`    | `[...]`    | 序列化构造运算符 |
| `cctor`    | `{=}`      | 拷贝构造运算符   |
| `mctor`    | `{<}`      | 移动构造运算符   |
| `dtor`     | `{~}`      | 析构运算符       |
| `member`   | `.`        | 成员运算符       |
| `locate`   | `#`        | 定位运算符       |
| `move`     |            | 移动运算符       |
| `negative` | `-`        | 负               |
| `bitrev`   | `~`        | 位取反           |
| `increase` | `++`       | 自增             |
| `decrease` | `--`       | 自减             |
| `index`    | `[]`       | 下标运算         |
| `assign`   | `=`        | 赋值运算         |
| `add`      | `+`        |                  |
| `sub`      | `-`        |                  |
| `mul`      | `*`        |                  |
| `div`      | `/`        |                  |
| `mol`      | `%`        |                  |
| `bitand`   | `&`        |                  |
| `bitor`    | `|`        |                  |
| `bitxor`   | `^`        |                  |
| `shl`      | `<<`       |                  |
| `shr`      | `>>`       |                  |
| `lt`       | `<`        |                  |
| `gt`       | `>`        |                  |
| `le`       | `<=`       |                  |
| `ge`       | `>=`       |                  |
| `eq`       | `==`       |                  |
| `ne`       | `!=`       |                  |

复合赋值运算符通过组合运算符标签来获得标签，语法请参见文档《20190507-运算符语法设计》。

### 执行流展开

使用**do**关键字引导的执行流展开语句，语法如下

~~~
do Proc on Task then Calback;
~~~

### 返回过程

使用**do**关键字引导返回过程。

~~~
do return : {...};
~~~

## 特性约定

特性约定表示，当一个类满足足够的条件时，被视为一种特定的类。

### 容器

1. 迭代器子类

   容器类应当拥有名为`iterator`和`citerator`的两个子类。

   分别满足**迭代器约定**和**受限迭代器约定**。

2. 迭代方法

   容器类应当拥有如下方法

   `begin`和`cbegin`方法返回一个起始迭代器。

   `end`和`cend`方法返回一个结束迭代器。

### 迭代器

1. 提取方法

   `method get() ref Type`

   `method const get() ref const Type`

2. 迭代方法

   `method inc () ref this class`

### 元组

1. 是模板类

   对每个模板参数都有原型存储

2. 提取运算符

   对每个模板参数都有提取运算符

   `operator # n () ref Type `

   `operator const # n () ref const Type`

# 模块签名

## 入口标记

在模块签名中添加入口标记语法支持，去除了前缀式的入口方法标记方案。

~~~
module App entry main : dep
~~~

入口方法必须是透明类中的元方法，计目的是简化词法分析器中的微型语法分析器。

## 带集合的依赖描述符

```
module Test : {io memory string}@linux
```

提供集中描述来自相同程序的依赖的语法支持。

## 带变量的依赖描述符

```
module Test : usb@"driver-$(sys)-$(cpu)"
```

在`iString`描述的程序中，可以使用`$()`引导一个编译器变量。

编译器变量存放在编译器配置文件中，其值与编译器的安装环境有关，提供了使用相同的源码适配不同平台的语法支持。

## 带通配符的依赖描述符

~~~
module Test : *@linux
~~~

通过通配符引用一个模块中所有的模块，自动去重。

# 元素类型关键

在`Alioth0.9`中修改了`VAR`和`VAL`两种元素类型的关键字和对应名称。

```
var --> obj
val --> rel
```

## OBJ

**OBJ**表示此元素与对象直接绑定。

## REL

**REL**表示此元素将重定位对象的作用域。

# 组合关键字

`Alioth0.9`引入了一系列组合关键字语法，提供了一些特化指代语法支持。

## 当前类

`this class`关键字用于表示当前类，是一个**类型用例**。

抽象类的方法的返回值被指定为**this class**，此方法就会在各个子类中被自动正确重载。如果方法的算法不需要改变，则手动书写这样的重载就会浪费时间。

除了让一个抽象方法自动被重载以外，当前类在其他语境也可以被使用，作为简单的统一指代。

## 当前模块

在依赖描述符中，若指定依赖模块的别名为`this module`则表示进行语法树根合并。

~~~
module App : dep as this module
~~~

## 返回对象

`return obj`组合关键字指代返回值对象，是一个元素。

此语法特性提供了在返回之前访问返回对象的语法支持，这样可以避免由返回造成的拷贝等开销。

~~~
return obj .data = read(buf);
return obj .lock = true;
return return obj;
~~~

# 执行流

`Alioth-0.9`重新敲定了关于执行流的语法规则。

## Lambda

~~~
obj fun = $( arg1 Type, arg2 Type ) obj Type {
	Do something...
};
~~~

使用`$()`引导**Lambda**表达式的构造。

与之前设计的语法规则类似，**Lambda**表达式可以是准，虚，可以使用可变参数包。

## Unwind

`Unwind`语句将执行流展开。

~~~
do Processor on TaskSet then {
	// Do something ...
}
~~~

* 任务集 TaskSet

  - 任务集满足**Alioth容器**约定
  - 任务集满足**Alioth元组**约定
  - 任务集是数字

* 宿主 Host

  宿主满足**执行流展开宿主**约定

* 处理器 Processor

  * 处理器可以是**方法**
  * 处理器也可以是**Lambda表达式**

* 看门狗

  剩余部分描述一个看门狗过程，看门狗过程在每个任务完成时被出发，并且一定在当前执行流被执行。

  第一个参数是执行流的索引，对于元组任务集，索引和切面对应。

  第二个参数是迭代器，若任务集是容器，可以获取当前迭代器。
  
~~~
do proc on task then callback;
~~~

## Return

~~~
do return : proc;
~~~

返回过程用于注册一个离开此作用域时一定被执行的过程。

返回过程可以多次注册，最后会被按顺序执行。

# 前导语境

Alioth使用一些关键字可以引导一些特殊的语境，临时改变语法规则。

## 类型语境

在`Alioth`中，模板参数列表的打开`<`和运算符`<`是一样的。

`Alioth`规定仅在不可能出现关系运算符`<`的语境中将`<`分析为模板参数列表。

在表达式中，要创造这样的语境，需要使用`class`关键字来引导一个短暂的类型描述语境。

## 取引用

要对一个元素所绑定的取引用，可以使用`ref`引导一个取引用语境，简化`Obj as ref`式的语法结构。

~~~
return ref Obj;
~~~

## 取重载

要对一个元素取重载，可以使用`rel`引导一个取重载的语境，简化`Obj as rel`式的语法结构

~~~
store( rel Obj );
~~~

# 运算符修饰

通过运算符修饰，可以实现**删除**运算符，**产生默认**运算符,**反重载**或**正反同构**运算符。

之前语法中的设计过度使用了`$`这个通用的修饰符，没有考虑到用户的记忆成本，对此设计者做出了反省，并设计了更友好的运算符修饰策略。

## 反重载

若希望标记一个运算符是反重载运算符，可以在运算符之前加上一个约定的`rev`标记，`rev`标记只在运算符定义和运算符实现的签名语境中有效，并不是新增的关键字，在任何其他位置依然可以被当做一个标识符正常使用。

~~~
operator rev + ( obj Type ) obj Type
~~~

`rev`标记是单词**reverse**的缩写。

<u>注意，单目运算符和赋值运算符不能被反重载。</u>

## 正反同构

若正反重载的运算符拥有着完全相同的算法，都针对参数进行相同的操作，那么重复写两次算法相同的运算符实现就是在浪费时间。

Alioth提供了运算符正反同构机制，标记一个运算符是正反同构的，编译器会生成一个算法完全相同的反重载运算符。

~~~
operator ism + ( obj Type ) obj Type
~~~

`ism`关键字用于表示一个运算符是正反同构的，和`rev`一样，`ism`标记也是一个约定，它不是保留字，在任何其他语境中可以作为标识符正常使用。

`ism`标记是单词**isomorphic**的缩写。

<u>注意，不能反重载的运算符都不能标记为正反同构。</u>

## 删除运算符

对于一个复合数据类型，有些**特化运算符**是原本就存在的，若用户即不希望重载这些运算符也不希望其他模块使用这些运算符，那么，可以为这个运算符打上一个删除标签。

~~~
delete default operator {=} // 删除了拷贝构造运算符
~~~

原本拥有，可以被删除的特化运算符如下表所列：

| 运算符记法 | 运算符标签 | 描述                   |
| ---------- | ---------- | ---------------------- |
| `{...}`    | sctor      | 默认的结构化构造运算符 |
| `{=}`      | cctor      | 默认的拷贝构造运算符   |
| `{<}`      | mctor      | 默认的移动构造运算符   |

## 产生默认运算符

对于一些复合数据类型原本不拥有，但是算法很简单的运算符，编译器可以帮助用户生成默认版本。

~~~
operator default assign ( ref const this class ) ref this class
operator default assign ( rel this class ) ref this class
~~~

## 方法原始符号

可以使用`raw`约定方法在生成目标文件时，产生原始符号。

~~~
method met raw () void
method met raw "symbol" () void
~~~

