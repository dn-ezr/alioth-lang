# Alioth 编程语言 0.7 : 编程指南

本文档所描述的语法对应于alioth语言的0.7版本

## 资源组织

不同于 *gcc* 以**源文件**为最小编译单位,**alioth**以模块为最小的编译单位,而一个模块又可以由多份**源文档**描述,所以,**alioth**需要一种模式,用于有效的将编译期间编译器所需的资源组织起来.

### 应用

使用**alioth**可以产生**可执行文件**,**静态链接库**或**动态链接库**,无论是什么,**编译产物**连同与它们关联的**文档**,**文件**共同构成了**应用**,其语义是<u>*对**alioth**语言的应用的产物*</u>.

此处的**应用**并非常用的**应用程序**的概念,而是广义上指通过**alioth**应用管理机制发布,安装的任何**数字资源**.

**应用**可以包含**可执行程序**,**动态链接库**和**静态链接库**中的任何内容,也可以包含**alioth源文档**,这些内容会被**alioth**组织起来,在编写新的项目时,可以通过**alioth**引用这些资源.

### 空间

alioth将其在运行环境中的活动范围分割为两个**空间**, 分别为**工作空间**和**根空间**.

通常情况下,这两个空间分别与两个磁盘路径对应,其中**根空间**与**alioth**的安装路径对应,**工作空间**为**当前工作目录**.

alioth编译器从**根空间**读取默认配置,寻找**alioth**的基础库,同时,使用**alioth**安装的**应用**

每一个使用**alioth**安装的应用的安装目录都被视为一个**应用空间**.

### 子空间

子空间是对空间对应的路径的几个特定子路径的抽象.

因为一旦空间被重定向成其他数据源,子空间就不一定是文件系统路径了.

alioth规定的子空间有如下几个,对工作空间来说,这几个子空间的对应路径全是可配置的.

* Arc : 用于存放作为静态链接库的编译产物
* Bin : 用于存放作为可执行程序的编译产物
* Doc : 用于存放伴随应用一起发布的文档
* Inc : 用于存放模型源文档
* Lib : 用于存放作为动态链接库的编译产物
* Obj : 用于存放编译中间产物
* Src : 拥有存放模块源文档

### 模块

alioth的最小编译单元是**模块**,每个模块有自己的名字,可以对应多份**源代码文档**.

### 源文档

根据**alioth**对工作空间的管理规则,用户不能也不需要在编译时指定编译哪些文件.

**alioth**会自动寻找目标模块对应的**源文档**来组织语法树信息,编译产生目标代码.

在空间**S**中,满足下列规则的**文件**被视为**源文档**

* 文件存在于**Inc**或**Src**子空间中
* 文件后缀名是".alioth"或文件拥有合法的**模块定义**

## 模块定义语句

> <span style="color:red">注:</span> 下述EBNF表达式分为**词法**和**语法**两种,**语法**表达式中"<span style="font-weight:900;color:blue">,</span>"运算符只起到分割终结符名的作用,不包含连接语义,如果不加特殊说明,语法表达式中任何逗号运算符出现的位置对应的源代码中都可以任意插入空白符或注释.

模块定义语句是源文档中第一条有效语句,定义**源文档**与**模块**的对应关系,同时描述模块的**依赖**信息.

语法如下:

~~~ebnf
module define = "module", label, [":", {dependency}], [";"] ;
~~~

其中**dependency**是对模块的一个依赖的描述,我们稍后认识它.

**label**是**alioth**中的标签终结符,在此表示当前模块的模块名,其词法如下:

~~~ebnf
label = label letter, { label letter | digit } ;
label letter = "A" | "B" | "C" | "D" | "E" | "F" | "G"
       | "H" | "I" | "J" | "K" | "L" | "M" | "N"
       | "O" | "P" | "Q" | "R" | "S" | "T" | "U"
       | "V" | "W" | "X" | "Y" | "Z" | "a" | "b"
       | "c" | "d" | "e" | "f" | "g" | "h" | "i"
       | "j" | "k" | "l" | "m" | "n" | "o" | "p"
       | "q" | "r" | "s" | "t" | "u" | "v" | "w"
       | "x" | "y" | "z" | "_" ;
digit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;
~~~

例程:
~~~alioth
/** 定义一个名为Hello的模块的源文档 */
module Hello
~~~

## 依赖描述

依赖描述本身并不是语句,但是它的语法比较松散,如果放在模块定义中一起介绍,语法范式会让人难以理解.

~~~ebnf
module name = label;
app name = label|literal string|literal character|".";
alias = "this" | label;
dependency = module name, ["@", app name], ["as" alias] ;
~~~

其中,**module name**试图引用的模块的模块名.  

**app name**是可选的,指定模块所属的应用.  
其中包含了四中可选的写法,分别是**标识符**,**字面字符串**,**字面字符**,**点**.  
在此语境中,这些终结符的语义不再是原语义,而是无论如何,都表达其字面语义.  
当所写内容表达为一个点  "." 时,表示要引用的模块应当来自当前模块所在的应用.  
其他任何写法,都寻找所表达的字符串对应的应用名.

> 此处允许使用**字面字符串**和**字面字符**两种终结符有两个相关思考  
> 1. 首先应用名称可以很复杂而超出**标识符**的表达能力  
> 1. 其次,**字面字符**和**字面字符串**拥有相同的内容词法规则,也就是说如果语义允许,其实单引号也可以包括一个字符串.而这里就是语义允许的地方.

其中**字面字符串**的词法规则与**C**语言大致相似,使用双引号包含字符串内容哦.而**字面字符**的词法规则与**字面字符串**几乎相同,差别在于它使用**单引号**包括字符串内容.

**alias**表示可选的,可以给引用的模块取一个别名,可用于避免符号冲突,可以用于减少工作量.

当**alias**写做**this**时,表示将此模块视为**本模块的扩展**,其别名为本模块名,当两个模块中包含同名的全局定义时,这会引起符号冲突.

但是,条件允许的情况下,这能节省一次次书写模块名的时间,当工作量越来越大时,表达思路的方式越简短,开发的效率就会越高.

当您的引用语句没有指定模块所属的应用时,alioth根据**依赖检索规则**检索您所指定的依赖项,工作流程如下:
1. 首先,在当前模块所在的应用中查找目标模块  
1. 若上一步失败,在alioth根空间中查找模块  
1. 若上一步也失败,在所有应用空间中查找模块  
此时若存在多个应用包含名为依赖名的模块,则报告**依赖选项不唯一**的错误.

**alioth**关于依赖还有最后两个限制:
1. 模块不能依赖自身,也不能在任何依赖层次中形成循环依赖
1. 任何模块的依赖层次不能超过三层

例程:

~~~alioth
/** 引入alioth提供的astring模块,将其并入本地模块,这样就能自由使用
 *      astring模块提供的string类了 */
module Test :
    astring as this 
    net @ alioth
    io
    io @ 'IBM:commen driver;3.19' as dio ;
~~~

## 类定义

**alioth**是面向对象的编程语言,对象是属性的集合,而忽略状态,对对象的抽象就是**数据类型**.

**alioth**拥有足够的**基础数据类型**,使用这些基础数据类型,可以构建更复杂的**复合数据类型**,而书写**类定义**是设计**复合数据类型**的手段.

一份完整的类定义,包括两方面的信息,**物理特征**和**行为特征**.

## 附录A:关键字列表

|词法符号|词法规则|语义描述|
|---|---|---|
|ASK|?|功能广泛的符号,在不同语境的语义不同,通常表达询问或示弱的语义|
|FORCE|!|功能广泛的符号,在不同的语境语义不同,通常表达强制或质疑的语义|
|CONV|$|功能广泛的符号,通常表示考虑事物的另一面|
|OPENA|(|常用界符之一,通常表示打开一个子式|
|OPENL|[|常用界符之一,通常表示打开一个定位,也可以用于引导列构造表达式或执行流展开语句|
|OPENS|{|常用界符之一,通常表示打开一个域,也可以用于引导构造表达式|
|CLOSEA|)|常用界符,通常用于表示对应界符的结束|
|CLOSEL|]|常用界符,通常用于表示对应界符的结束|
|CLOSES|}|常用界符,通常用于表示对应界符的结束|
|COLON|:|于...;则...;<br/>常用界符,通常表示顺承语义|
|COMMA|,|并且...;然后...;<br/>常用界符,表示递进语义,用于分割参数,也可以引导列表达式,用于列赋值运算|
|SEMI|;|常用界符之一,表达终止语义,用于分割上下句|
|AT|@|在...;坐落于...;<br/>带有修饰语义,通常用于表达符号意义上的定位|
|MODULE|module|通常用于指代模块|
|MODEL|model|通常用于指代模型|
|ENTRY|entry|通常指代入口|
|IMPORT|import|引入,通常用于引导模块引用语句|
|AS|as|类型转换运算,也用于引导模块别名|
|TREAT|as!|强制类型对待|
|ASSUME|assume|假设语义,通常引导类型假设语境|
|OTHERWISE|otherwise|否则,通常表达假设的转折语义,用于继续引导类型假设语境|
|ASSIGN|=|赋值语义,通常表示令左侧与右侧相等|
|ASSIGN_PLUS|+=|复合赋值运算|
|ASSIGN_MINUS|-=|复合赋值运算|
|ASSIGN_MUL|*=|复合赋值运算|
|ASSIGN_DIV|/=|复合赋值运算|
|ASSIGN_MOL|%=|复合赋值运算|
|ASSIGN_SHL|<<=|复合赋值运算|
|ASSIGN_SHR|>>=|复合赋值运算|
|ASSIGN_bAND|&=|复合赋值运算|
|ASSIGN_bOR|\|=|复合赋值运算|
|ASSIGN_bXOR|^=|复合赋值运算|