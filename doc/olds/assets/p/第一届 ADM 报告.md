# 第一届 ADM(Alioth Developer Meeting) 报告

> 王雨泽 2018/12/06

## 1. 议题总览

1. 模板参数列表与关系运算符歧义的问题及解决方案
2. 元素原型约束与指针层次语义表述不清的问题及解决方案
3. 定义与实现界限模糊导致编译器实现复杂的问题及解决方案

## 2. 出席成员

|ID|mail|
|:--|--:|
|ezr|stinger121@live.com|
|Dragon|2278117063@qq.com|
|BlackEyes|zhanggd@sau.edu.cn|

## 3. 议程记录

### 3.1. 模板参数列表与关系运算符歧义的问题及解决方案

Alioth原定(0.7及以下)语法规定,模板类型的模板参数列表紧随模板类名之后,由尖括号包括.

由于Alioth规定**定义无序**,在表达式语境中通过鉴定前缀名称的身份,区别类名与元素名对后续**LT**的理解从而解决语法歧义的方案不可行.

#### 3.1.1. 枚举解决方案

* 更换包括**模板参数列表**所使用的符号为原不能用作**中缀运算符**的符号.
* 改模板参数列表**语序**为模板类名之**前缀**.
* 改拥有**模板参数列表**的模板类名语法,使用类似`Lisp`的整体包括语法.
* 加语法限制,仅在确定不能出现**关系运算符**的语境中允许使用**模板参数列表**.

#### 3.1.2. 方案决策

经多方考虑,最终决定采用`加语法限制`方案解决语义歧义问题.

### 3.2. 元素原型约束与指针层次语义表述不清的问题与解决方案

Alioth原定(0.7及以下)语法规定,元素约束置于元素名称之前,元素数据类型约束置于元素名称之后.

上述设计忽略了在一些语境中元素原型不包括元素名称的情况,当元素名称被忽略,将无法区分元素约束与数据类型约束之间的差别.

#### 3.2.1. 枚举解决方案

* 改数据类型约束`const *`为`^`,语义为`数据类型为指向下述数据类型对象的指针数据类型,受只读约束`.
  语法设计:
  ~~~ebnf
  element prototype = 
    element type , ["const"] , [label] , ["*"|"^"] , ( basic dada type | composite data type usage );
  ~~~

#### 3.2.2. 方案决策

经多方讨论,暂时只能提出上述一种方案,故无需决策,采取上述语法设计.

### 3.3. 定义与实现界限模糊导致编译器实现复杂的问题及解决方案

Alioth原定(0.7及以下)语法规定导致`方法`与`运算符`的`定义`与`实现`之间的界限很模糊.

现提出下文所述几条语法规则,改善情况.

#### 3.3.1. 新增语法规则

##### 3.3.1.1. 方法与运算符的定义与实现

规定只有在`module`层次上书写的`method`和`operator`被允许携带实现体,并被视为`实现`,是确切的区别于`定义`的语法结构.

书写在任何其他位置的`method`或`operator`均被视为`定义`,是确切的区别于`实现`的语法结构,其中不允许携带实现体.

##### 3.3.1.2. 透明方法

规定与类同名的成员方法称为`透明方法`,必须被标记为`静态`,并且其名称将被注入类所在的定义域.

##### 3.3.1.3. 透明类

规定与模块同名的模块级类定义称为`透明类`,其中所有定义的名称将被注入类所在的定义域,并不再递归遵循`透明类`语法规则.

透明类中不能包含成员运算符定义,不能包含静态成员.

#### 3.3.2. 方法实现的语法设计

~~~ebnf
method implementation = 
  "method" , {"const"|"static"} , seme , ">" , label , parameter list , return prototype , executable block ;
~~~

其中`seme`对应于一个可以携带模板参数的类名.

#### 3.3.3. 运算符实现的语法设计

~~~ebnf
operator implementation = 
  "operator" , {"const"|"static"} , seme , ">" , operator , parameter list , ...... ;
~~~

其中省略处遵循原定语法设计,本次修改不涉及其内容.

### 3.3. 衍生议题

#### 3.3.1. 关于移动运算符

移动运算符的存在,是为编程人员考虑到了,对象有可能闭包时,应当对此事件有所感知,并执行相应处理.

* 程序员应确保可能被闭包的对象所属的数据类型,被正确重载了移动运算符.
* 若元素拥有`$`标记,表示程序员知道此对象可能闭包,并确切的知道无论是否已经重载移动运算符,都是期望的解决方案.

#### 3.3.2. 关于依赖层次限制

修改原定通过修改编译器项目源代码修改依赖层次限制的设计为可以通过配置文件修改限制层次数量.

此设计可以避免为开放性的大规模项目带来传播过程中本不必要的开销和麻烦,减少开源成本.